{
	"leetcode": {
		"prefix": "leetcode",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"$0"
		],
		"description": "Leetcode C++ header"
	},
	"main": {
		"prefix": "main",
		"body": [
			"int main() {",
			"\t$0",
			"\treturn 0;",
			"}"
		],
		"description": "C/C++ main function without arguments"
	},
	"maina": {
		"prefix": "maina",
		"body": [
			"int main(int argc, char **argv) {",
			"\t$0",
			"\treturn 0;",
			"}"
		],
		"description": "C/C++ main function with arguments"
	},
	"TreeNode": {
		"prefix": "TreeNode",
		"body": [
			"struct TreeNode {",
			"\tint val;",
			"\tTreeNode *left;",
			"\tTreeNode *right;",
			"\tTreeNode() : val(0), left(nullptr), right(nullptr) {}",
			"\tTreeNode(int x) : val(x), left(nullptr), right(nullptr) {}",
			"\tTreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}",
			"};"
		],
		"description": "Leetcode TreeNode definition"
	},
	"inorder": {
		"prefix": "inorder",
		"body": [
			"void inorder(TreeNode *root) {",
			"\tif (root) {",
			"\t\tinorder(root->left);",
			"\t\tcout << root->val << \" \";",
			"\t\tinorder(root->right);",
			"\t}",
			"\tcout << endl;",
			"}",
			"$0"
		],
		"description": "Inorder traverse"
	},
	"preorder": {
		"prefix": "preorder",
		"body": [
			"void preorder(TreeNode *root) {",
			"\tif (root) {",
			"\t\tcout << root->val << \" \";",
			"\t\tpreorder(root->left);",
			"\t\tpreorder(root->right);",
			"\t}",
			"\tcout << endl;",
			"}",
			"$0"
		],
		"description": "Preorder traverse"
	},
	"postorder": {
		"prefix": "postorder",
		"body": [
			"void postorder(TreeNode *root) {",
			"\tif (root) {",
			"\t\tpostorder(root->left);",
			"\t\tpostorder(root->right);",
			"\t\tcout << root->val << \" \";",
			"\t}",
			"\tcout << endl;",
			"}",
			"$0"
		],
		"description": "Postorder traverse"
	},
	"level_traverse": {
		"prefix": "level_traverse",
		"body": [
			"void level_traverse(TreeNode *root) {",
			"\tqueue<TreeNode *> q;",
			"\tif (root) {",
			"\t\tq.push(root);",
			"\t}",
			"\twhile (!q.empty()) {",
			"\t\tconst auto node = q.front();",
			"\t\tq.pop();",
			"\t\tif (node->left) {",
			"\t\t\tq.push(node->left);",
			"\t\t}",
			"\t\tif (node->right) {",
			"\t\t\tq.push(node->right);",
			"\t\t}",
			"\t\tcout << node->val << \" \";",
			"\t}",
			"\tcout << endl;",
			"}",
			"$0"
		],
		"description": "Level traverse"
	},
	"construct_binary_tree": {
		"prefix": "construct_binary_tree",
		"body": [
			"#ifndef null",
			"#define null -1",
			"#endif",
			"TreeNode *construct_binary_tree(const vector<int> &vec) {",
			"\tvector<TreeNode *> vecTree(vec.size(), NULL);",
			"\tTreeNode *root = NULL;",
			"\tfor (int i = 0; i < vec.size(); i++) {",
			"\t\tTreeNode *node = NULL;",
			"\t\tif (vec[i] != -1) {",
			"\t\t\tnode = new TreeNode(vec[i]);",
			"\t\t}",
			"\t\tvecTree[i] = node;",
			"\t\tif (i == 0) {",
			"\t\t\troot = node;",
			"\t\t}",
			"\t}",
			"\tfor (int i = 0; i * 2 + 2 < vec.size(); i++) {",
			"\t\tif (vecTree[i] != NULL) {",
			"\t\t\tvecTree[i]->left = vecTree[i * 2 + 1];",
			"\t\t\tvecTree[i]->right = vecTree[i * 2 + 2];",
			"\t\t}",
			"\t}",
			"\treturn root;",
			"}",
			"$0"
		]
	}
}
